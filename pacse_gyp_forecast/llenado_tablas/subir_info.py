import pandas as pd
from datetime import date

#Esta linea importa la conexión a la base de datos por defecto: from django.db import connection
from django.db import connection
from django.conf import settings
from django.utils.timezone import make_aware, get_default_timezone
from pytz import timezone
import pytz
from django.shortcuts import render
from django.db import transaction

from pacse_gyp_forecast.models import Product, Sales, Category,Stock,Status
import pacse_gyp_forecast.llenado_tablas.filtro_info_inicial as filtro_info_inicial


# Nuevas
def cortar_dataframe(df):
    with open("pacse_gyp_forecast/log/log.log", 'r') as archivo:
        contenido = archivo.read()

    if len(contenido) > 0:
        lineas = contenido.splitlines()
        ultima_lectura = lineas[-1]
        ultima_lectura = pd.to_datetime(ultima_lectura)
        if ultima_lectura != df['Fecha de compra'].iloc[-1]:
            df_filtrado = df[df['Fecha de compra'] >= ultima_lectura]
            return df_filtrado
        else:
            return df
    else:
        return df

def obtener_ventas_desde_ultima_venta(sales_df: pd.DataFrame) -> pd.DataFrame:
    print("cortar dataframe")
    settings.TIME_ZONE
    zona_horaria = pytz.timezone('UTC')

    last_sale = Sales.objects.order_by('-date').first()  # Última venta guardada en la base de datos
    if last_sale:
        product = Product.objects.get(pk=last_sale.Product_id)  # Producto correspondiente a la última venta
        sku = product.SKU
        
        # Convertir la columna de fechas a objetos datetime
        sales_df['Fecha de compra'] = sales_df['Fecha de compra'].apply(make_aware)
        sales_df['Fecha de compra'] = sales_df['Fecha de compra'] + pd.Timedelta(hours=3)
        

        # Filtrar las ventas posteriores a la última venta en la base de datos
        #sales_since_last_sale = sales_df[(sales_df['Fecha de compra'] > last_sale.date) & (sales_df['SKU Master'] == sku)]
        sales_since_last_sale = sales_df[(sales_df['Fecha de compra'] > last_sale.date)]
        
        return sales_since_last_sale
    else:
        # Convertir la columna de fechas a objetos datetime
        sales_df['Fecha de compra'] = sales_df['Fecha de compra'].apply(make_aware)
        sales_df['Fecha de compra'] = sales_df['Fecha de compra'] + pd.Timedelta(hours=3)
        return sales_df

def verificar_orden_fecha(df, columna_fecha,id):
    # Verificar si la columna está ordenada de forma ascendente
    orden_ascendente = df[columna_fecha].is_monotonic_increasing

    # Verificar si la columna está ordenada de forma descendente
    orden_descendente = df[columna_fecha].is_monotonic_decreasing

    # Devolver True si está ordenada de forma ascendente o descendente, False en caso contrario
    if orden_ascendente or orden_descendente:
        print("ordenada ",id)
        return True
    else:
        print("Desornada ",id)
        return False

def sort_cut_dataframe(data):
    data = data.sort_values('Fecha de compra')
    data = obtener_ventas_desde_ultima_venta(data)
    return data


def guardar_log(data):
    fecha= str(data['Fecha de compra'].iloc[-1])
    with open("pacse_gyp_forecast/log/log.log", 'w') as archivo:
        archivo.write(fecha)



# SUBIR INFORMACIÓN INICIAL
# Ingresar categorias
def subir_info_inicial_categoria(df):

    # Conectar a la base de datos PostgreSQL
    cursor = connection.cursor()

    # APARTADO PARA SUBIR INFORMACIÓN DE LA TABLA "CATEGORY"

    # Se filtra la información a subir
    categorias = filtro_info_inicial.obtener_info_columna_específica_df(df, 'Clase')

    # Verificar si la tabla existe y crearla si no existe
    cursor.execute("SELECT EXISTS(SELECT relname FROM pg_class WHERE relname='pacse_gyp_forecast_category')")
    exists = cursor.fetchone()[0]
    if not exists:
        sql_crear_tabla_category = """CREATE TABLE IF NOT EXISTS public.pacse_gyp_forecast_category(id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
                                        description character varying(30) COLLATE pg_catalog."default" NOT NULL, CONSTRAINT pacse_gyp_forecast_category_pkey PRIMARY KEY (id));"""
        cursor.execute(sql_crear_tabla_category)

    # Consultar si existen elementos en la tabla
    cantidad_category = Category.objects.count()

    if cantidad_category > 0:
        print("Caso 1")
        sql_insert_tabla_category = """INSERT INTO public.pacse_gyp_forecast_category (description)
                                        SELECT %s WHERE NOT EXISTS (SELECT 1 FROM public.pacse_gyp_forecast_category WHERE description = %s);
                                        """
        # Insertar los datos en la tabla de la base de datos
        for categoria in categorias:
            cursor.execute(sql_insert_tabla_category, (categoria,categoria))
        connection.commit()
    else:
        print("Caso 2")
        sql_insert_tabla_category = "INSERT INTO public.pacse_gyp_forecast_category(description) VALUES (%s)"
        # Insertar los datos en la tabla de la base de datos
        for categoria in categorias:
            cursor.execute(sql_insert_tabla_category, (categoria,))
        connection.commit()
    # Cerrar la conexión a la base de datos
    cursor.close()
    connection.close()


def subir_info_inicial_status():
    status_iniciales = ["Bien, Aprox. Más de 2 meses", "Regular, Aprox. 1 mes", "Peligro, Aprox. Menos de 2 semanas", "Sin estado"]
    # Conectar a la base de datos PostgreSQL
    cursor = connection.cursor()

    # Verificar si la tabla existe y crearla si no existe
    cursor.execute("SELECT EXISTS(SELECT relname FROM pg_class WHERE relname='pacse_gyp_forecast_status')")

    exists = cursor.fetchone()[0]
    if not exists:
        sql_crear_tabla_status = """CREATE TABLE IF NOT EXISTS public.pacse_gyp_forecast_status (id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),name character varying(30) COLLATE pg_catalog."default" NOT NULL,CONSTRAINT pacse_gyp_forecast_status_pkey PRIMARY KEY (id));"""
        cursor.execute(sql_crear_tabla_status)

    # Consultar si existen elementos en la tabla
    cantidad_status = Status.objects.count()

    if cantidad_status > 0:
        print("Caso 1")
        sql_insert_tabla_status = """INSERT INTO public.pacse_gyp_forecast_status (name)
                                        SELECT %s WHERE NOT EXISTS (SELECT 1 FROM public.pacse_gyp_forecast_status WHERE name = %s);
                                        """
        # Insertar los datos en la tabla de la base de datos
        for status in status_iniciales:
            cursor.execute(sql_insert_tabla_status, (status,status))
        connection.commit()
    else:
        print("Caso 2")
        sql_insert_tabla_status = "INSERT INTO public.pacse_gyp_forecast_status(name) VALUES (%s)"

        # Insertar los datos en la tabla de la base de datos
        for status in status_iniciales:
            cursor.execute(sql_insert_tabla_status, (status,))
        connection.commit()

    # Cerrar la conexión a la base de datos
    cursor.close()
    connection.close()


def subir_info_inicial_producto(df):
    # Conectar a la base de datos PostgreSQL
    cursor = connection.cursor()

    column_categorias = Category.objects.values_list('description', flat=True)
    categorias = list(column_categorias)

    df_productos = filtro_info_inicial.obtener_info_inicial_productos_df(df,categorias)

    # Verificar si la tabla existe y crearla si no existe
    cursor.execute("SELECT EXISTS(SELECT relname FROM pg_class WHERE relname='pacse_gyp_forecast_product')")
    exists = cursor.fetchone()[0]

    if not exists:
        sql_crear_tabla_producto = """CREATE TABLE IF NOT EXISTS public.pacse_gyp_forecast_product(
                                    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
                                    "SKU" character varying(30) COLLATE pg_catalog."default" NOT NULL,
                                    description character varying(100) COLLATE pg_catalog."default" NOT NULL,
                                    restock_time integer NOT NULL,
                                    ignored boolean NOT NULL,
                                    deleted boolean NOT NULL,
                                    known boolean NOT NULL,
                                    "Category_id" bigint NOT NULL,
                                    "Status_id" bigint NOT NULL,CONSTRAINT pacse_gyp_forecast_product_pkey PRIMARY KEY (id),CONSTRAINT "pacse_gyp_forecast_product_SKU_key" UNIQUE ("SKU"),CONSTRAINT "pacse_gyp_forecast_p_Category_id_bd36891a_fk_pacse_gyp" FOREIGN KEY ("Category_id")
                                        REFERENCES public.pacse_gyp_forecast_category (id) MATCH SIMPLE
                                        ON UPDATE NO ACTION
                                        ON DELETE NO ACTION
                                        DEFERRABLE INITIALLY DEFERRED,
                                    CONSTRAINT "pacse_gyp_forecast_p_Status_id_1c41ef9e_fk_pacse_gyp" FOREIGN KEY ("Status_id")
                                        REFERENCES public.pacse_gyp_forecast_status (id) MATCH SIMPLE
                                        ON UPDATE NO ACTION
                                        ON DELETE NO ACTION
                                        DEFERRABLE INITIALLY DEFERRED);"""
        cursor.execute(sql_crear_tabla_producto)

    # Consultar si existen elementos en la tabla
    #cursor.execute("SELECT COUNT(*) FROM public.pacse_gyp_forecast_product")
    #result = cursor.fetchone()
    cantidad_product = Product.objects.count()

    if cantidad_product > 0:
        print("Caso 1")
        for index, row in df_productos.iterrows():
            sku = row['SKU Master']
            description = row['Descripcion Master']
            restock_periods = 0
            ignored = False
            deleted = False
            known = True
            category_id = row['Clase']
            if not Product.objects.filter(SKU=sku).exists():
                product = Product(SKU=sku, description=description, restock_time = restock_periods, ignored=ignored, deleted = deleted, known = known, Category_id=category_id, Status_id=4)
                product.save()

    else:
        print("Caso 2")
        sql_insert_tabla_product =  """INSERT INTO public.pacse_gyp_forecast_product("SKU", description, restock_time, ignored, deleted, known,"Category_id", "Status_id")
                                VALUES (%s, %s, %s, %s, %s, %s, %s, %s);"""

        # Insertar los datos en la tabla de la base de datos
        for index, row in df_productos.iterrows():
            data = (row['SKU Master'], row['Descripcion Master'], 0, False , False, True, row['Clase'], "4")
            cursor.execute( sql_insert_tabla_product , data)
        connection.commit()

    # Cerrar la conexión a la base de datos
    cursor.close()
    connection.close()


def subir_info_inicial_stock():
    # Conectar a la base de datos PostgreSQL
    cursor = connection.cursor()

    # Verificar si la tabla existe y crearla si no existe
    cursor.execute("SELECT EXISTS(SELECT relname FROM pg_class WHERE relname='pacse_gyp_forecast_stock')")
    exists = cursor.fetchone()[0]

    if not exists:
        sql_crear_tabla_stock = """CREATE TABLE IF NOT EXISTS public.pacse_gyp_forecast_stock
                                    (
                                        id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
                                        quantity integer NOT NULL,
                                        date date NOT NULL,
                                        "Product_id" bigint NOT NULL,
                                        CONSTRAINT pacse_gyp_forecast_stock_pkey PRIMARY KEY (id),
                                        CONSTRAINT "pacse_gyp_forecast_s_Product_id_8dc3e3e2_fk_pacse_gyp" FOREIGN KEY ("Product_id")
                                            REFERENCES public.pacse_gyp_forecast_product (id) MATCH SIMPLE
                                            ON UPDATE NO ACTION
                                            ON DELETE NO ACTION
                                            DEFERRABLE INITIALLY DEFERRED
                                    );"""
        
    # Consultar si existen elementos en la tabla
    cantidad_stock = Stock.objects.count()

    if cantidad_stock > 0:
        print("Caso 1")
        cursor.execute("SELECT COUNT(*) FROM public.pacse_gyp_forecast_product")
        result1 = cursor.fetchone()
        
        for index in range(result1[0]):
            fecha_actual = date.today()
            #data = (0, fecha_actual, index+1)
            #cursor.execute( sql_insert_tabla_stock , data + data)

            if not Stock.objects.filter(Product_id=index+1).exists():
                stock_data = Stock(quantity=0, date=fecha_actual, Product_id=index+1)
                stock_data.save()

        #connection.commit()

    else:
        print("Caso 2")
        cursor.execute("SELECT COUNT(*) FROM public.pacse_gyp_forecast_product")
        result1 = cursor.fetchone()
        sql_insert_tabla_stock = """INSERT INTO public.pacse_gyp_forecast_stock(quantity, date, "Product_id") VALUES ( %s, %s, %s);"""
        for index in range(result1[0]):
            fecha_actual = date.today()
            data = (0, fecha_actual, index+1)
            cursor.execute( sql_insert_tabla_stock , data)
        connection.commit()

    # Cerrar la conexión a la base de datos
    cursor.close()
    connection.close()


def subir_info_inicial_ventas(df):

    # Conectar a la base de datos PostgreSQL
    cursor = connection.cursor()

    # Verificar si la tabla existe y crearla si no existe
    cursor.execute("SELECT EXISTS(SELECT relname FROM pg_class WHERE relname='pacse_gyp_forecast_sales')")
    exists = cursor.fetchone()[0]

    if not exists:
        sql_crear_tabla_sales = """CREATE TABLE IF NOT EXISTS public.pacse_gyp_forecast_sales(
                                    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
                                    date timestamp with time zone NOT NULL,units integer NOT NULL,"Product_id" bigint NOT NULL,
                                    CONSTRAINT pacse_gyp_forecast_sales_pkey PRIMARY KEY (id),
                                    CONSTRAINT "pacse_gyp_forecast_s_Product_id_012bae60_fk_pacse_gyp" FOREIGN KEY ("Product_id")
                                        REFERENCES public.pacse_gyp_forecast_product (id) MATCH SIMPLE
                                        ON UPDATE NO ACTION
                                        ON DELETE NO ACTION
                                        DEFERRABLE INITIALLY DEFERRED
                                )"""

    # Consultar si existen elementos en la tabla
    #cursor.execute("SELECT COUNT(*) FROM public.pacse_gyp_forecast_sales")
    #result = cursor.fetchone()
    cantidad_sales = Sales.objects.count()
    
    if cantidad_sales > 0:
        # Hacer log para filtrar el excel
        settings.TIME_ZONE
        with transaction.atomic():
            # Recorrer el dataframe de ventas
            i = 1
            for index, row in df.iterrows():
                sku = row['SKU Master']
                fecha_compra = row['Fecha de compra']
                unidades = row['Unidades']
                
                # Obtener el producto correspondiente al SKU en la tabla Producto
                product = Product.objects.get(SKU=sku)
                
                #fecha_compra_TZ = make_aware(fecha_compra)
                

                # Verificar si ya existe una venta con el mismo producto y fecha
                existing_sale = Sales.objects.filter(Product=product, date=fecha_compra, units = unidades).exists()
                
                if not existing_sale:
                    # Crear un objeto de Ventas relacionado al producto
                    sale = Sales.objects.create(
                        date=fecha_compra,
                        units=unidades,
                        Product_id=product.id
                    )
                    
                    # Guardar la venta en la base de datos
                    sale.save()
                    print("Venta %i guardada" % i)
                    i += 1
                else:
                    print("Venta %i duplicada, no se guarda" % i)
    else:
        #CASO DONDE NO HAY INFORMACIÓN
        # Hacer log para filtrar el excel

        settings.TIME_ZONE
        with transaction.atomic():
            # Recorrer el dataframe de ventas
            i = 1
            for index, row in df.iterrows():
                sku = row['SKU Master']
                fecha_compra = row['Fecha de compra']
                unidades = row['Unidades']
                
                # Obtener el producto correspondiente al SKU en la tabla Producto
                product = Product.objects.get(SKU=sku)
                
                #fecha_compra = make_aware(fecha_compra)

                # Crear un objeto de Ventas relacionado al producto
                sale = Sales.objects.create(
                    date=fecha_compra,
                    units=unidades,
                    Product_id=product.id
                )
                
                # Guardar la venta en la base de datos
                sale.save()
                print("Venta %i guardada" %i)
                i+=1
    # Cerrar la conexión a la base de datos
    cursor.close()
    connection.close()

def cargar_datos_inicial_bd(data):
    #data = data.sort_values('Fecha de compra')
    #verificar_orden_fecha(data, "Fecha de compra",1)
    #data = obtener_ventas_desde_ultima_venta(data)
    #si hay informacion nueva
    if not data.empty:
        subir_info_inicial_categoria(data)
        #verificar_orden_fecha(data, "Fecha de compra",2)
        subir_info_inicial_status()
        subir_info_inicial_producto(data)
        #verificar_orden_fecha(data, "Fecha de compra",3)
        subir_info_inicial_stock()
        #verificar_orden_fecha(data, "Fecha de compra",4)
        subir_info_inicial_ventas(data)
        #verificar_orden_fecha(data, "Fecha de compra",5)
        print("Carga realizada")
    else:
        print("No hay informacion que actualizar")




# SUBIR INFORMACIÓN CON LA BD CARGADA
def subir_info_ventas(data):
    print("Funcion subida")

    i = 1
    for index, row in data.iterrows():
        # Se obtienen los datos a guardar de la venta
        sku_master = row['SKU Master']
        fecha_compra = row['Fecha de compra']
        unidades = row['Unidades']

         # Verificar la existencia del SKU Master de esta venta en la tabla Product
        if not Product.objects.filter(SKU=sku_master).exists():
            print("producto no esta en BD")
            new_product_description = row['Clase']
            if not Category.objects.filter(description= new_product_description).exists():
                
                new_category = Category.objects.create(description = new_product_description)
                new_category.save()

                new_product = Product.objects.create(
                    SKU = sku_master,
                    description = new_product_description,
                    restock_time = 0,
                    ignored = False,
                    deleted = False,
                    known =  False,
                    #FK attributes.
                    Category_id = new_category.id,
                    Status_id = 4
                )
                new_product.save()
                
                new_stock = Stock.objects.create(
                    quantity = 0,
                    date = date.today(),
                    #FK attributes.
                    Product_id = new_product.id
                )
                new_stock.save()

                new_sale = Sales.objects.create(
                    date=fecha_compra,
                    units=unidades,
                    Product_id= new_product.id
                )
                new_sale.save()

            else:
                category_asociated = Category.objects.get(description = new_product_description)

                #Para este caso la categoría si existe, entonces no es necesario añadirla a la base de datos
                new_product = Product.objects.create(
                    SKU = sku_master,
                    description = category_asociated.description,
                    restock_time = 0,
                    ignored = False,
                    deleted = False,
                    known =  False,
                    #FK attributes.
                    Category_id = category_asociated.id,
                    Status_id = 4
                )
                new_product.save()

                new_stock = Stock.objects.create(
                    quantity = 0,
                    date = date.today(),
                    #FK attributes.
                    Product_id = new_product.id
                )
                new_stock.save()

                new_sale = Sales.objects.create(
                    date=fecha_compra,
                    units=unidades,
                    Product_id= new_product.id
                )
                new_sale.save()
            
        else: # Si el producto existe en la base de datos, entonces se guarda la venta de forma normal
            # Obtener el producto correspondiente al SKU en la tabla Producto
            product = Product.objects.get(SKU=sku_master)

            # Crear un objeto de Ventas relacionado al producto
            sale = Sales.objects.create(
                date=fecha_compra,
                units=unidades,
                Product_id=product.id
            )
            # Guardar la venta en la base de datos
            sale.save()
        #print("Venta %i guardada" %i)
        #i+=1    

def cargar_datos_bd(data):
    #data = data.sort_values('Fecha de compra')
    #data = obtener_ventas_desde_ultima_venta(data)

    if not data.empty:
        subir_info_ventas(data)
        print("Carga realizada")
    else:
        print("No hay informacion que actualizar 2")
